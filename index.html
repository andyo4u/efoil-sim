<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E-Foil Simulator</title>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #000;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      color: white;
      z-index: 10;
    }
    
    .hud-panel {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      padding: 12px 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    #speed-display {
      position: absolute;
      top: 20px;
      left: 20px;
    }
    
    #speed-value {
      font-size: 48px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      line-height: 1;
    }
    
    #speed-unit {
      font-size: 18px;
      opacity: 0.7;
      margin-left: 4px;
    }
    
    #battery-display {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #battery-icon {
      font-size: 24px;
    }
    
    #battery-percent {
      font-size: 24px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
    }
    
    #battery-display.low {
      color: #ff4444;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    #height-gauge {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 80px;
    }
    
    #height-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .gauge-container {
      height: 120px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .gauge-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, #00ff88, #00ccff);
      transition: height 0.1s;
    }
    
    .gauge-sweet-spot {
      position: absolute;
      left: 0;
      right: 0;
      height: 30%;
      top: 35%;
      background: rgba(0, 255, 136, 0.2);
      border-top: 1px dashed rgba(0, 255, 136, 0.5);
      border-bottom: 1px dashed rgba(0, 255, 136, 0.5);
    }
    
    .gauge-value {
      position: absolute;
      bottom: -25px;
      left: 0;
      right: 0;
      text-align: center;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
    }
    
    #throttle-gauge {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 80px;
    }
    
    #throttle-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 8px;
      text-align: center;
    }
    
    #throttle-fill {
      background: linear-gradient(to top, #ff8800, #ffcc00);
    }
    
    #assist-badge {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      background: rgba(0, 200, 100, 0.6);
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      border: 1px solid rgba(0, 255, 136, 0.3);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #assist-badge.visible {
      opacity: 1;
    }
    
    #state-indicator {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      font-size: 14px;
      font-weight: bold;
      border-radius: 4px;
      transition: all 0.3s;
    }
    
    #state-indicator.displacement {
      background: rgba(100, 100, 255, 0.5);
      border: 1px solid rgba(150, 150, 255, 0.5);
    }
    
    #state-indicator.foiling {
      background: rgba(0, 255, 136, 0.5);
      border: 1px solid rgba(0, 255, 136, 0.5);
    }
    
    #state-indicator.breach {
      background: rgba(255, 100, 0, 0.5);
      border: 1px solid rgba(255, 150, 0, 0.5);
    }
    
    #controls-hint {
      position: absolute;
      bottom: 160px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 16px 24px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      opacity: 0;
      transition: opacity 0.5s;
      text-align: center;
      max-width: 400px;
    }
    
    #controls-hint.visible {
      opacity: 1;
    }
    
    #controls-hint h3 {
      margin-bottom: 12px;
      font-size: 16px;
      color: #00ff88;
    }
    
    .mobile-only { display: none; }
    @media (pointer: coarse) {
      .desktop-only { display: none; }
      .mobile-only { display: block; }
    }
    
    #controls-hint p {
      font-size: 13px;
      line-height: 1.6;
      opacity: 0.9;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="hud">
    <div id="speed-display" class="hud-panel">
      <span id="speed-value">0</span>
      <span id="speed-unit">km/h</span>
    </div>
    
    <div id="battery-display" class="hud-panel">
      <span id="battery-icon">âš¡</span>
      <span id="battery-percent">100%</span>
    </div>
    
    <div id="assist-badge" class="visible">STABILITY ASSIST</div>
    
    <div id="state-indicator" class="displacement">DISPLACEMENT</div>
    
    <div id="height-gauge">
      <div id="height-label">HEIGHT</div>
      <div class="gauge-container">
        <div class="gauge-sweet-spot"></div>
        <div id="height-fill" class="gauge-fill"></div>
      </div>
      <div class="gauge-value" id="height-value">0.0m</div>
    </div>
    
    <div id="throttle-gauge">
      <div id="throttle-label">THROTTLE</div>
      <div class="gauge-container">
        <div id="throttle-fill" class="gauge-fill"></div>
      </div>
      <div class="gauge-value" id="throttle-value">0%</div>
    </div>
    
    <div id="wave-display" class="hud-panel" style="position:absolute; top:80px; left:20px;">
      <span style="font-size:12px; opacity:0.7;">WAVE</span><br>
      <span id="wave-value" style="font-size:24px; font-weight:bold; font-family:'Courier New',monospace;">0.0m</span>
    </div>

    <!-- Wave Control Panel -->
    <button id="wave-toggle" style="position:absolute; top:120px; right:20px; z-index:20; pointer-events:auto; background:rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.2); color:white; padding:8px 14px; border-radius:6px; cursor:pointer; font-size:13px; backdrop-filter:blur(10px);">ðŸŒŠ Waves</button>
    <div id="wave-panel" style="display:none; position:absolute; top:155px; right:20px; z-index:20; pointer-events:auto; background:rgba(0,0,0,0.8); border:1px solid rgba(255,255,255,0.15); border-radius:10px; padding:16px; backdrop-filter:blur(12px); width:280px; max-height:70vh; overflow-y:auto;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="font-weight:bold; color:#00ccff;">ðŸŒŠ Wave Controls</span>
        <button id="wave-add" style="pointer-events:auto; background:#00ccff33; border:1px solid #00ccff55; color:#00ccff; padding:4px 10px; border-radius:4px; cursor:pointer; font-size:12px;">+ Add Swell</button>
      </div>
      <div id="swell-list"></div>
    </div>

    <div id="controls-hint" class="visible">
      <h3>ðŸŽ® CONTROLS</h3>
      <p class="desktop-only"><strong>W/S</strong> - Throttle Up/Down</p>
      <p class="desktop-only"><strong>A/D</strong> - Turn Left/Right</p>
      <p class="desktop-only"><strong>SHIFT</strong> - Lean Back (Rise)</p>
      <p class="desktop-only"><strong>SPACE</strong> - Lean Forward (Descend)</p>
      <p class="desktop-only"><strong>T</strong> - Toggle Stability Assist</p>
      <p class="mobile-only"><strong>Right side</strong> - Drag up/down for throttle</p>
      <p class="mobile-only"><strong>Left side</strong> - Drag to steer & pitch</p>
    </div>
  </div>

  <script type="module">
    // =====================================================================
    // E-FOIL SIMULATOR - MVP v0.1 with Gerstner Waves
    // =====================================================================
    
    import * as THREE from 'three';
    import { Sky } from 'three/addons/objects/Sky.js';
    
    // =====================================================================
    // CONSTANTS
    // =====================================================================
    
    const PHYSICS = {
      MASS: 100,
      MAX_THRUST: 200,
      WING_AREA: 0.12,
      MAST_LENGTH: 0.75,
      WATER_DENSITY: 1025,
      GRAVITY: 9.81,
      
      // Lift coefficient curve [aoa, Cl]
      CL_CURVE: [[0, 0], [4, 0.5], [8, 1.0], [10, 1.2], [12, 1.3], [14, 0.4], [16, 0.2]],
      
      CD_FOIL: 0.03,
      CD_HULL: 0.15,
      
      STAB_GAIN: 50,
      STAB_DAMP: 30,
      
      BASE_DRAIN: 0.0002,
      POWER_DRAIN: 0.001,
      
      THROTTLE_RAMP_UP: 0.8,
      THROTTLE_RAMP_DOWN: 0.5,
      PITCH_SENSITIVITY: 2.0,
      TURN_RATE: 1.5,
      
      ASSIST_DAMPING: 0.6,
      
      // Sweet spot for optimal height
      SWEET_SPOT_MIN: 0.3,
      SWEET_SPOT_MAX: 0.6,
    };
    
    // =====================================================================
    // WAVE / SWELL SYSTEM - Gerstner Waves
    // =====================================================================

    const swells = [
      { height: 0.3, period: 8, steepness: 0.5, direction: 0, enabled: true },
      { height: 0.15, period: 5, steepness: 0.3, direction: 45, enabled: true },
    ];

    // Gerstner wave calculation - returns position displacement
    function getWaveDisplacement(x, z, time) {
      let dx = 0, dy = 0, dz = 0;
      
      for (const s of swells) {
        if (!s.enabled) continue;
        
        const dirRad = s.direction * Math.PI / 180;
        const dirX = Math.cos(dirRad);
        const dirZ = Math.sin(dirRad);
        
        const waveLen = (PHYSICS.GRAVITY * s.period * s.period) / (2 * Math.PI);
        const k = (2 * Math.PI) / waveLen;
        const omega = Math.sqrt(PHYSICS.GRAVITY * k);
        
        const amplitude = s.height / 2;
        const steepness = Math.min(s.steepness, 1.0 / (k * amplitude * swells.filter(sw => sw.enabled).length));
        
        const phase = k * (x * dirX + z * dirZ) - omega * time;
        const c = Math.cos(phase);
        const sn = Math.sin(phase);
        
        // Gerstner wave displacement
        dx -= steepness * amplitude * dirX * c;
        dy += amplitude * sn;
        dz -= steepness * amplitude * dirZ * c;
      }
      
      return { x: dx, y: dy, z: dz };
    }

    // Get just the height for physics (what the shader will show)
    function getWaveHeight(x, z, time) {
      const disp = getWaveDisplacement(x, z, time);
      return disp.y;
    }

    function buildSwellPanel() {
      const list = document.getElementById('swell-list');
      list.innerHTML = '';
      swells.forEach((s, i) => {
        const div = document.createElement('div');
        div.style.cssText = 'margin-bottom:14px; padding:10px; background:rgba(255,255,255,0.05); border-radius:6px; border:1px solid rgba(255,255,255,0.1);';
        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <span style="font-size:13px; font-weight:bold; color:#7ec8e3;">Swell ${i + 1}</span>
            <div>
              <label style="font-size:11px; cursor:pointer;"><input type="checkbox" ${s.enabled ? 'checked' : ''} data-i="${i}" data-p="enabled" style="cursor:pointer;"> On</label>
              <button data-del="${i}" style="background:none; border:none; color:#ff6666; cursor:pointer; font-size:14px; margin-left:6px;">âœ•</button>
            </div>
          </div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
            ${sliderHTML('Height', 'height', i, s.height, 0, 2, 0.05, 'm')}
            ${sliderHTML('Period', 'period', i, s.period, 2, 20, 0.5, 's')}
            ${sliderHTML('Steepness', 'steepness', i, s.steepness, 0, 1, 0.05, '')}
            ${sliderHTML('Direction', 'direction', i, s.direction, 0, 360, 5, 'Â°')}
          </div>
        `;
        list.appendChild(div);
      });
      // Wire events
      list.querySelectorAll('input[type=range]').forEach(el => {
        el.addEventListener('input', (e) => {
          const i = +e.target.dataset.i;
          const p = e.target.dataset.p;
          swells[i][p] = +e.target.value;
          e.target.parentElement.querySelector('.sv').textContent = e.target.value + (e.target.dataset.u || '');
        });
      });
      list.querySelectorAll('input[type=checkbox]').forEach(el => {
        el.addEventListener('change', (e) => {
          swells[+e.target.dataset.i].enabled = e.target.checked;
        });
      });
      list.querySelectorAll('button[data-del]').forEach(el => {
        el.addEventListener('click', (e) => {
          swells.splice(+e.target.dataset.del, 1);
          buildSwellPanel();
        });
      });
    }

    function sliderHTML(label, prop, i, val, min, max, step, unit) {
      return `<div style="font-size:11px;">
        <div style="display:flex; justify-content:space-between; opacity:0.7;"><span>${label}</span><span class="sv">${val}${unit}</span></div>
        <input type="range" min="${min}" max="${max}" step="${step}" value="${val}" data-i="${i}" data-p="${prop}" data-u="${unit}" style="width:100%; cursor:pointer; accent-color:#00ccff;">
      </div>`;
    }

    // Wire toggle + add buttons after DOM ready
    document.getElementById('wave-toggle').addEventListener('click', () => {
      const panel = document.getElementById('wave-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      if (panel.style.display === 'block') buildSwellPanel();
    });
    document.getElementById('wave-add').addEventListener('click', () => {
      swells.push({ height: 0.2, period: 6, steepness: 0.3, direction: 90, enabled: true });
      buildSwellPanel();
    });

    // =====================================================================
    // STATE
    // =====================================================================
    
    const state = {
      position: new THREE.Vector3(0, 0, 0),
      velocity: new THREE.Vector3(0, 0, 0),
      rotation: { pitch: 0, yaw: 0, roll: 0 },
      angularVelocity: { pitch: 0, yaw: 0, roll: 0 },
      
      throttle: 0.0,
      throttleInput: 0.0,
      pitchInput: 0.0,
      turnInput: 0.0,
      
      speed: 0,
      heightAboveWater: 0,
      waveHeight: 0,
      angleOfAttack: 0,
      battery: 1.0,
      
      isFoiling: false,
      isCrashed: false,
      crashTime: 0,
      
      stabilityAssist: true,
      
      time: 0,
    };
    
    // =====================================================================
    // INPUT MANAGER
    // =====================================================================
    
    class InputManager {
      constructor() {
        this.keys = {};
        
        window.addEventListener('keydown', (e) => {
          this.keys[e.code] = true;
          
          // Toggle stability assist
          if (e.code === 'KeyT') {
            state.stabilityAssist = !state.stabilityAssist;
            this.updateAssistBadge();
          }
        });
        
        window.addEventListener('keyup', (e) => {
          this.keys[e.code] = false;
        });
        
        this.initTouch();
      }
      
      update() {
        // Throttle input
        if (this.keys['KeyW'] || this.keys['ArrowUp']) {
          state.throttleInput = 1.0;
        } else if (this.keys['KeyS'] || this.keys['ArrowDown']) {
          state.throttleInput = -1.0;
        } else {
          state.throttleInput = 0.0;
        }
        
        // Turn input
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
          state.turnInput = 1.0;
        } else if (this.keys['KeyD'] || this.keys['ArrowRight']) {
          state.turnInput = -1.0;
        } else {
          state.turnInput = 0.0;
        }
        
        // Pitch input
        if (this.keys['ShiftLeft'] || this.keys['ShiftRight']) {
          state.pitchInput = 1.0; // Lean back = nose up
        } else if (this.keys['Space']) {
          state.pitchInput = -1.0; // Lean forward = nose down
        } else {
          state.pitchInput = 0.0;
        }
        
        // Touch overrides keyboard if active
        this.updateTouch();
      }
      
      initTouch() {
        this.touchThrottle = null;
        this.touchSteer = null;
        
        const canvas = document.getElementById('canvas-container');
        
        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          for (const t of e.changedTouches) {
            if (t.clientX > window.innerWidth / 2) {
              this.touchThrottle = { id: t.identifier, startY: t.clientY, currentY: t.clientY };
            } else {
              this.touchSteer = { id: t.identifier, startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY };
            }
          }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          for (const t of e.changedTouches) {
            if (this.touchThrottle && t.identifier === this.touchThrottle.id) {
              this.touchThrottle.currentY = t.clientY;
            }
            if (this.touchSteer && t.identifier === this.touchSteer.id) {
              this.touchSteer.currentX = t.clientX;
              this.touchSteer.currentY = t.clientY;
            }
          }
        }, { passive: false });
        
        const endTouch = (e) => {
          for (const t of e.changedTouches) {
            if (this.touchThrottle && t.identifier === this.touchThrottle.id) this.touchThrottle = null;
            if (this.touchSteer && t.identifier === this.touchSteer.id) this.touchSteer = null;
          }
        };
        canvas.addEventListener('touchend', endTouch);
        canvas.addEventListener('touchcancel', endTouch);
      }
      
      updateTouch() {
        // Right side: drag up = throttle, drag down = brake
        if (this.touchThrottle) {
          const dy = (this.touchThrottle.startY - this.touchThrottle.currentY) / 100;
          state.throttleInput = Math.max(-1, Math.min(1, dy));
        }
        // Left side: horizontal = turn, vertical = pitch
        if (this.touchSteer) {
          const dx = (this.touchSteer.currentX - this.touchSteer.startX) / 60;
          const dy = (this.touchSteer.startY - this.touchSteer.currentY) / 60;
          state.turnInput = -Math.max(-1, Math.min(1, dx));
          state.pitchInput = Math.max(-1, Math.min(1, dy));
        }
      }
      
      updateAssistBadge() {
        const badge = document.getElementById('assist-badge');
        badge.classList.toggle('visible', state.stabilityAssist);
      }
    }
    
    // =====================================================================
    // PHYSICS ENGINE
    // =====================================================================
    
    class PhysicsEngine {
      constructor() {
        this.dt = 1/60; // Fixed timestep
      }
      
      // Get Cl from angle of attack using piecewise linear interpolation
      getCl(aoa) {
        const curve = PHYSICS.CL_CURVE;
        
        if (aoa <= curve[0][0]) return curve[0][1];
        if (aoa >= curve[curve.length - 1][0]) return curve[curve.length - 1][1];
        
        for (let i = 0; i < curve.length - 1; i++) {
          const [aoa1, cl1] = curve[i];
          const [aoa2, cl2] = curve[i + 1];
          
          if (aoa >= aoa1 && aoa <= aoa2) {
            const t = (aoa - aoa1) / (aoa2 - aoa1);
            return cl1 + t * (cl2 - cl1);
          }
        }
        
        return 0;
      }
      
      update() {
        if (state.isCrashed) {
          // Simple recovery countdown
          state.crashTime += this.dt;
          if (state.crashTime > 2.0) {
            this.resetToFloating();
          }
          return;
        }
        
        // Update throttle with ramping
        const rampRate = state.throttleInput > 0 ? PHYSICS.THROTTLE_RAMP_UP : PHYSICS.THROTTLE_RAMP_DOWN;
        const targetThrottle = Math.max(0, state.throttle + state.throttleInput * rampRate * this.dt);
        state.throttle = THREE.MathUtils.clamp(targetThrottle, 0, 1);
        
        // Calculate forces
        const forward = new THREE.Vector3(
          Math.sin(state.rotation.yaw),
          0,
          Math.cos(state.rotation.yaw)
        );
        
        // Thrust
        const batteryEff = 0.7 + 0.3 * state.battery;
        const thrust = state.throttle * PHYSICS.MAX_THRUST * batteryEff;
        const thrustForce = forward.clone().multiplyScalar(thrust);
        
        // Speed and angle of attack
        state.speed = state.velocity.length();
        const velocityAngle = state.speed > 0.1 ? 
          Math.atan2(state.velocity.y, Math.sqrt(state.velocity.x**2 + state.velocity.z**2)) * 180/Math.PI : 0;
        state.angleOfAttack = state.rotation.pitch - velocityAngle;
        
        // Height above water using Gerstner wave system
        state.waveHeight = getWaveHeight(state.position.x, state.position.z, state.time);
        state.heightAboveWater = state.position.y - state.waveHeight;
        
        // Lift (only when foil is submerged)
        let liftForce = new THREE.Vector3();
        const foilDepth = -state.heightAboveWater + 0.3; // Board bottom offset
        
        if (foilDepth > 0 && foilDepth < PHYSICS.MAST_LENGTH && state.speed > 0.1) {
          const cl = this.getCl(state.angleOfAttack);
          const liftMag = 0.5 * PHYSICS.WATER_DENSITY * state.speed**2 * PHYSICS.WING_AREA * cl;
          
          // Lift is perpendicular to velocity, biased upward
          const liftDir = new THREE.Vector3(0, 1, 0);
          liftForce = liftDir.multiplyScalar(liftMag);
        }
        
        // Drag (two regimes)
        let dragForce = new THREE.Vector3();
        const inWater = state.heightAboveWater < 0.1;
        const dragCoef = inWater ? PHYSICS.CD_HULL : PHYSICS.CD_FOIL;
        const dragArea = inWater ? 0.8 : 0.02;
        
        if (state.speed > 0.1) {
          const dragMag = 0.5 * PHYSICS.WATER_DENSITY * state.speed**2 * dragArea * dragCoef;
          dragForce = state.velocity.clone().normalize().multiplyScalar(-dragMag);
        }
        
        // Gravity
        const gravityForce = new THREE.Vector3(0, -PHYSICS.MASS * PHYSICS.GRAVITY, 0);
        
        // Buoyancy when in water
        let buoyancyForce = new THREE.Vector3();
        if (state.heightAboveWater < 0) {
          const submergedVolume = Math.abs(state.heightAboveWater) * 0.5; // Simplified
          const buoyancy = PHYSICS.WATER_DENSITY * PHYSICS.GRAVITY * submergedVolume;
          buoyancyForce = new THREE.Vector3(0, buoyancy, 0);
        }
        
        // Net force
        const netForce = new THREE.Vector3()
          .add(thrustForce)
          .add(liftForce)
          .add(dragForce)
          .add(gravityForce)
          .add(buoyancyForce);
        
        // Integration
        const acceleration = netForce.divideScalar(PHYSICS.MASS);
        state.velocity.add(acceleration.multiplyScalar(this.dt));
        state.position.add(state.velocity.clone().multiplyScalar(this.dt));
        
        // Pitch control
        const pitchTorque = state.pitchInput * PHYSICS.PITCH_SENSITIVITY;
        
        // Stabilizer (automatic pitch correction)
        const stabTorque = -PHYSICS.STAB_GAIN * state.rotation.pitch - 
                          PHYSICS.STAB_DAMP * state.angularVelocity.pitch;
        
        let totalPitchTorque = pitchTorque + stabTorque;
        
        // Apply stability assist damping
        if (state.stabilityAssist) {
          state.angularVelocity.pitch *= PHYSICS.ASSIST_DAMPING;
        }
        
        state.angularVelocity.pitch += totalPitchTorque * this.dt;
        state.rotation.pitch += state.angularVelocity.pitch * this.dt;
        state.rotation.pitch = THREE.MathUtils.clamp(state.rotation.pitch, -45, 45);
        
        // Yaw control (turning)
        const turnRate = state.turnInput * PHYSICS.TURN_RATE;
        state.rotation.yaw += turnRate * this.dt;
        
        // Roll from turning
        state.rotation.roll = -state.turnInput * 15; // degrees
        
        // Update foiling state
        state.isFoiling = state.heightAboveWater > 0.1 && state.heightAboveWater < PHYSICS.MAST_LENGTH;
        
        // Battery drain
        const drain = PHYSICS.BASE_DRAIN + PHYSICS.POWER_DRAIN * state.throttle**2;
        state.battery = Math.max(0, state.battery - drain * this.dt);
        
        // Crash detection
        this.checkCrash();
        
        // Time
        state.time += this.dt;
      }
      
      checkCrash() {
        const stall = state.angleOfAttack > 12 || state.angleOfAttack < -5;
        const breach = state.heightAboveWater > PHYSICS.MAST_LENGTH;
        const noseDive = state.rotation.pitch < -30 && state.isFoiling;
        
        if ((stall || breach || noseDive) && state.isFoiling && state.speed > 5) {
          state.isCrashed = true;
          state.crashTime = 0;
          
          // Show crash splash effect
          this.createSplash();
        }
      }
      
      createSplash() {
        // Visual feedback (could add particles here)
        console.log('ðŸ’¦ SPLASH!');
      }
      
      resetToFloating() {
        state.isCrashed = false;
        state.position.y = 0.3;
        state.velocity.set(0, 0, 0);
        state.rotation.pitch = 0;
        state.rotation.roll = 0;
        state.angularVelocity.pitch = 0;
        state.throttle = 0;
      }
    }
    
    // =====================================================================
    // E-FOIL MODEL BUILDER
    // =====================================================================
    
    class EFoilModel {
      constructor() {
        this.group = new THREE.Group();
        this.buildModel();
      }
      
      buildModel() {
        const carbonMat = new THREE.MeshStandardMaterial({
          color: 0x111111, roughness: 0.2, metalness: 0.5
        });
        const boardMat = new THREE.MeshStandardMaterial({
          color: 0xffffff, roughness: 0.4
        });

        // 1. THE BOARD
        const boardLength = 1.1;
        const board = new THREE.Mesh(new THREE.BoxGeometry(boardLength, 0.08, 0.6), boardMat);
        const boardOffset = boardLength / 6;
        board.position.set(boardOffset, 0.85, 0);
        this.group.add(board);

        // 2. THE MAST
        const mast = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.85, 0.18), carbonMat);
        mast.position.set(0, 0.4, 0);
        mast.rotation.y = Math.PI / 2;
        this.group.add(mast);

        // 3. THE FUSELAGE
        const fuse = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.05, 0.05), carbonMat);
        fuse.position.set(-0.125, 0, 0);
        this.group.add(fuse);

        // 4. FRONT WING
        const fWing = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 1.1), carbonMat);
        fWing.position.set(0.25, 0, 0);
        fWing.scale.set(1, 1, 0.8);
        this.group.add(fWing);

        // 5. STABILIZER
        const bWing = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.02, 0.4), carbonMat);
        bWing.position.set(-0.5, 0, 0);
        this.group.add(bWing);

        // RIDER
        const riderMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const rider = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 0.6, 8, 16), riderMat);
        rider.position.set(boardOffset, 1.55, 0);
        this.group.add(rider);

        // HEAD
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.9 })
        );
        head.position.set(boardOffset, 2.05, 0);
        this.group.add(head);
      }
      
      update() {
        // Update model position and rotation
        this.group.position.copy(state.position);
        this.group.rotation.y = state.rotation.yaw;
        this.group.rotation.x = state.rotation.pitch * Math.PI / 180;
        this.group.rotation.z = state.rotation.roll * Math.PI / 180;
      }
    }
    
    // =====================================================================
    // GERSTNER WAVE SHADER
    // =====================================================================
    
    const vertexShader = `
      #define MAX_WAVES 8
      
      uniform float time;
      uniform int waveCount;
      uniform vec4 waveData[MAX_WAVES]; // x=amplitude, y=wavelength, z=speed, w=direction
      uniform vec3 cameraPosition;
      
      varying vec3 vWorldPos;
      varying vec3 vViewDir;
      varying float vWaveHeight;
      varying float vFoam;
      
      void main() {
        vec3 pos = position;
        vec3 tangent = vec3(1.0, 0.0, 0.0);
        vec3 binormal = vec3(0.0, 0.0, 1.0);
        
        float foam = 0.0;
        
        // Apply Gerstner waves
        for (int i = 0; i < MAX_WAVES; i++) {
          if (i >= waveCount) break;
          
          float amplitude = waveData[i].x;
          float wavelength = waveData[i].y;
          float speed = waveData[i].z;
          float direction = waveData[i].w;
          
          float k = 2.0 * 3.14159 / wavelength;
          float omega = speed * k;
          
          vec2 dir = vec2(cos(direction), sin(direction));
          float phase = k * dot(dir, position.xz) - omega * time;
          
          float c = cos(phase);
          float s = sin(phase);
          
          // Gerstner displacement
          float steepness = 0.6 / (k * amplitude * float(waveCount));
          pos.x -= steepness * amplitude * dir.x * c;
          pos.z -= steepness * amplitude * dir.y * c;
          pos.y += amplitude * s;
          
          // Accumulate derivatives for normals
          float wa = k * amplitude;
          float kx = k * dir.x;
          float kz = k * dir.y;
          
          tangent.x -= steepness * kx * kx * amplitude * s;
          tangent.y += kx * amplitude * c;
          tangent.z -= steepness * kx * kz * amplitude * s;
          
          binormal.x -= steepness * kx * kz * amplitude * s;
          binormal.y += kz * amplitude * c;
          binormal.z -= steepness * kz * kz * amplitude * s;
          
          // Foam where waves converge (simplified)
          foam += steepness * 0.5;
        }
        
        // Compute normal from tangent and binormal
        vec3 normal = normalize(cross(binormal, tangent));
        
        vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
        vViewDir = normalize(cameraPosition - vWorldPos);
        vWaveHeight = pos.y;
        vFoam = clamp(foam * 2.0, 0.0, 1.0);
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;
    
    const fragmentShader = `
      uniform vec3 sunPosition;
      uniform vec3 deepColor;
      uniform vec3 shallowColor;
      uniform float time;
      
      varying vec3 vWorldPos;
      varying vec3 vViewDir;
      varying float vWaveHeight;
      varying float vFoam;
      
      void main() {
        // Recompute normal from derivatives using dFdx/dFdy for accurate per-fragment normals
        vec3 dPdx = dFdx(vWorldPos);
        vec3 dPdy = dFdy(vWorldPos);
        vec3 normal = normalize(cross(dPdx, dPdy));
        
        // Fresnel effect
        float fresnel = pow(1.0 - max(dot(normal, vViewDir), 0.0), 3.0);
        
        // Base ocean color with depth
        float depthFactor = clamp(vWaveHeight * 0.3 + 0.5, 0.0, 1.0);
        vec3 waterColor = mix(deepColor, shallowColor, depthFactor);
        
        // Sun specular
        vec3 sunDir = normalize(sunPosition);
        vec3 reflected = reflect(-vViewDir, normal);
        float specular = pow(max(dot(reflected, sunDir), 0.0), 128.0);
        vec3 specularColor = vec3(1.0, 1.0, 0.9) * specular * 0.8;
        
        // Fresnel blend with sky reflection
        vec3 skyColor = vec3(0.5, 0.7, 0.9);
        vec3 finalColor = mix(waterColor, skyColor, fresnel * 0.4);
        finalColor += specularColor;
        
        // Foam on wave crests
        float foamMask = smoothstep(0.4, 0.8, vWaveHeight + 0.2);
        foamMask *= vFoam;
        vec3 foamColor = vec3(1.0, 1.0, 1.0);
        finalColor = mix(finalColor, foamColor, foamMask * 0.6);
        
        // Semi-transparent
        float alpha = 0.95;
        
        gl_FragColor = vec4(finalColor, alpha);
      }
    `;
    
    // =====================================================================
    // GAME RENDERER
    // =====================================================================
    
    class GameRenderer {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        
        this.setupSky();
        this.setupLights();
        this.setupWater();
        this.setupEFoil();
        
        window.addEventListener('resize', () => this.onResize());
      }
      
      setupLights() {
        // Sunlight
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(100, 100, 50);
        this.scene.add(sun);
        
        // Ambient
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambient);
        
        // Hemisphere light for better sky-ground gradient
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
        this.scene.add(hemiLight);
      }
      
      setupWater() {
        // Create water mesh with Gerstner waves
        const waterGeometry = new THREE.PlaneGeometry(200, 200, 256, 256);
        
        // Prepare wave data for shader
        this.waveData = [];
        for (let i = 0; i < 8; i++) {
          this.waveData.push(new THREE.Vector4(0, 1, 1, 0));
        }
        
        this.waterMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            waveCount: { value: 0 },
            waveData: { value: this.waveData },
            sunPosition: { value: new THREE.Vector3(0.7, 0.5, 0.3).normalize() },
            deepColor: { value: new THREE.Color(0x001e32) },
            shallowColor: { value: new THREE.Color(0x0066aa) },
            cameraPosition: { value: this.camera.position }
          },
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          transparent: true,
          side: THREE.DoubleSide,
        });
        
        this.water = new THREE.Mesh(waterGeometry, this.waterMaterial);
        this.water.rotation.x = -Math.PI / 2;
        this.scene.add(this.water);
      }
      
      setupSky() {
        this.sky = new Sky();
        this.sky.scale.setScalar(10000);
        this.scene.add(this.sky);
        
        const skyUniforms = this.sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 2;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        
        // Golden hour sun position
        const phi = THREE.MathUtils.degToRad(75);
        const theta = THREE.MathUtils.degToRad(30);
        this.sunPosition = new THREE.Vector3();
        this.sunPosition.setFromSphericalCoords(1, phi, theta);
        skyUniforms['sunPosition'].value.copy(this.sunPosition);
        
        // Update water shader sun position
        this.waterMaterial.uniforms.sunPosition.value.copy(this.sunPosition);
        
        // Fog for horizon blend
        this.scene.fog = new THREE.Fog(0x87ceeb, 100, 2000);
      }
      
      setupEFoil() {
        this.efoil = new EFoilModel();
        this.scene.add(this.efoil.group);
      }
      
      update() {
        this.efoil.update();
        
        // Update water shader uniforms
        this.waterMaterial.uniforms.time.value = state.time;
        this.waterMaterial.uniforms.cameraPosition.value.copy(this.camera.position);
        
        // Update wave data from swells
        let waveIndex = 0;
        
        // Primary swells from UI
        for (const swell of swells) {
          if (!swell.enabled || waveIndex >= 8) continue;
          
          const amplitude = swell.height / 2;
          const wavelength = (PHYSICS.GRAVITY * swell.period * swell.period) / (2 * Math.PI);
          const k = (2 * Math.PI) / wavelength;
          const omega = Math.sqrt(PHYSICS.GRAVITY * k);
          const direction = swell.direction * Math.PI / 180;
          
          this.waveData[waveIndex].set(amplitude, wavelength, omega / k, direction);
          waveIndex++;
        }
        
        // Add detail waves
        const detailWaves = [
          { amp: 0.05, period: 2.5, dir: 80 },
          { amp: 0.08, period: 3.5, dir: 120 },
          { amp: 0.04, period: 1.8, dir: 200 },
          { amp: 0.06, period: 4.2, dir: 310 },
        ];
        
        for (const wave of detailWaves) {
          if (waveIndex >= 8) break;
          
          const amplitude = wave.amp;
          const wavelength = (PHYSICS.GRAVITY * wave.period * wave.period) / (2 * Math.PI);
          const k = (2 * Math.PI) / wavelength;
          const omega = Math.sqrt(PHYSICS.GRAVITY * k);
          const direction = wave.dir * Math.PI / 180;
          
          this.waveData[waveIndex].set(amplitude, wavelength, omega / k, direction);
          waveIndex++;
        }
        
        this.waterMaterial.uniforms.waveCount.value = waveIndex;
        
        // Center water mesh on player position
        this.water.position.x = state.position.x;
        this.water.position.z = state.position.z;
      }
      
      render() {
        this.renderer.render(this.scene, this.camera);
      }
      
      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }
    
    // =====================================================================
    // CAMERA CONTROLLER
    // =====================================================================
    
    class CameraController {
      constructor(camera, target) {
        this.camera = camera;
        this.target = target;
        this.offset = new THREE.Vector3(0, 1.5, -3);
        this.lookAtOffset = new THREE.Vector3(0, 0.5, 1);
        this.currentPosition = new THREE.Vector3();
        this.currentLookAt = new THREE.Vector3();

        // Freelook state
        this.freelook = false;
        this.freelookTimer = 0;
        this.freelookTimeout = 20; // seconds
        this.orbitYaw = 0;
        this.orbitPitch = 0;
        this.orbitDist = 3;
        this.dragging = false;
        this.lastMouse = { x: 0, y: 0 };

        // Mouse drag to freelook
        const el = document.getElementById('canvas-container');
        el.addEventListener('mousedown', (e) => {
          if (e.button === 0 || e.button === 2) {
            this.startFreelook(e.clientX, e.clientY);
          }
        });
        el.addEventListener('mousemove', (e) => {
          if (!this.dragging) return;
          const dx = e.clientX - this.lastMouse.x;
          const dy = e.clientY - this.lastMouse.y;
          this.orbitYaw -= dx * 0.005;
          this.orbitPitch = Math.max(-1.2, Math.min(1.2, this.orbitPitch - dy * 0.005));
          this.lastMouse = { x: e.clientX, y: e.clientY };
          this.freelookTimer = 0;
        });
        window.addEventListener('mouseup', () => { this.dragging = false; });
        el.addEventListener('contextmenu', (e) => e.preventDefault());

        // Scroll to zoom
        el.addEventListener('wheel', (e) => {
          e.preventDefault();
          this.enterFreelook();
          this.orbitDist = Math.max(1.5, Math.min(12, this.orbitDist + e.deltaY * 0.005));
          this.freelookTimer = 0;
        }, { passive: false });

        // Touch: two-finger for freelook
        el.addEventListener('touchstart', (e) => {
          if (e.touches.length === 2) {
            e.preventDefault();
            const t = e.touches[0];
            this.startFreelook(t.clientX, t.clientY);
          }
        }, { passive: false });
        el.addEventListener('touchmove', (e) => {
          if (!this.dragging || e.touches.length < 2) return;
          e.preventDefault();
          const t = e.touches[0];
          const dx = t.clientX - this.lastMouse.x;
          const dy = t.clientY - this.lastMouse.y;
          this.orbitYaw -= dx * 0.008;
          this.orbitPitch = Math.max(-1.2, Math.min(1.2, this.orbitPitch - dy * 0.008));
          this.lastMouse = { x: t.clientX, y: t.clientY };
          this.freelookTimer = 0;
        }, { passive: false });
        el.addEventListener('touchend', () => { this.dragging = false; });
      }

      startFreelook(x, y) {
        this.dragging = true;
        this.lastMouse = { x, y };
        this.enterFreelook();
      }

      enterFreelook() {
        if (!this.freelook) {
          this.orbitYaw = state.rotation.yaw + Math.PI;
          this.orbitPitch = 0.3;
          this.orbitDist = 3;
        }
        this.freelook = true;
        this.freelookTimer = 0;
      }
      
      update() {
        const dt = 1 / 60;

        if (this.freelook) {
          this.freelookTimer += dt;

          const cx = state.position.x + Math.sin(this.orbitYaw) * Math.cos(this.orbitPitch) * this.orbitDist;
          const cy = state.position.y + Math.sin(this.orbitPitch) * this.orbitDist + 0.5;
          const cz = state.position.z + Math.cos(this.orbitYaw) * Math.cos(this.orbitPitch) * this.orbitDist;
          const desiredPos = new THREE.Vector3(cx, cy, cz);

          this.currentPosition.lerp(desiredPos, 0.1);
          this.camera.position.copy(this.currentPosition);

          const lookTarget = state.position.clone().add(new THREE.Vector3(0, 0.5, 0));
          this.currentLookAt.lerp(lookTarget, 0.1);
          this.camera.lookAt(this.currentLookAt);
          this.camera.rotation.z = 0;

          if (this.freelookTimer > this.freelookTimeout) {
            this.freelook = false;
          }
          return;
        }

        // Follow cam
        const rotationMatrix = new THREE.Matrix4();
        rotationMatrix.makeRotationY(state.rotation.yaw);
        
        const desiredOffset = this.offset.clone().applyMatrix4(rotationMatrix);
        const desiredPosition = state.position.clone().add(desiredOffset);
        
        this.currentPosition.lerp(desiredPosition, 0.05);
        this.camera.position.copy(this.currentPosition);
        
        const desiredLookAtOffset = this.lookAtOffset.clone().applyMatrix4(rotationMatrix);
        const desiredLookAt = state.position.clone().add(desiredLookAtOffset);
        
        this.currentLookAt.lerp(desiredLookAt, 0.1);
        this.camera.lookAt(this.currentLookAt);
        
        this.camera.rotation.z = state.rotation.roll * Math.PI / 180 * 0.1;
      }
    }
    
    // =====================================================================
    // HUD CONTROLLER
    // =====================================================================
    
    class HUDController {
      constructor() {
        this.speedValue = document.getElementById('speed-value');
        this.batteryPercent = document.getElementById('battery-percent');
        this.batteryDisplay = document.getElementById('battery-display');
        this.heightFill = document.getElementById('height-fill');
        this.heightValue = document.getElementById('height-value');
        this.throttleFill = document.getElementById('throttle-fill');
        this.throttleValue = document.getElementById('throttle-value');
        this.stateIndicator = document.getElementById('state-indicator');
        this.waveValue = document.getElementById('wave-value');
        this.controlsHint = document.getElementById('controls-hint');
        
        // Hide controls hint after 10 seconds
        setTimeout(() => {
          this.controlsHint.classList.remove('visible');
        }, 10000);
      }
      
      update() {
        // Speed (m/s to km/h)
        const speedKmh = state.speed * 3.6;
        this.speedValue.textContent = Math.round(speedKmh);
        
        // Battery
        const batteryPercent = Math.round(state.battery * 100);
        this.batteryPercent.textContent = `${batteryPercent}%`;
        this.batteryDisplay.classList.toggle('low', state.battery < 0.2);
        
        // Height gauge (0-2m range)
        const heightPercent = Math.min(100, Math.max(0, (state.heightAboveWater / 2) * 100));
        this.heightFill.style.height = `${heightPercent}%`;
        this.heightValue.textContent = `${state.heightAboveWater.toFixed(1)}m`;
        
        // Wave height
        this.waveValue.textContent = `${state.waveHeight.toFixed(1)}m`;
        
        // Throttle gauge
        const throttlePercent = state.throttle * 100;
        this.throttleFill.style.height = `${throttlePercent}%`;
        this.throttleValue.textContent = `${Math.round(throttlePercent)}%`;
        
        // State indicator
        if (state.isCrashed) {
          this.stateIndicator.textContent = 'CRASHED';
          this.stateIndicator.className = 'breach';
        } else if (state.heightAboveWater >= PHYSICS.MAST_LENGTH) {
          this.stateIndicator.textContent = 'BREACH!';
          this.stateIndicator.className = 'breach';
        } else if (state.isFoiling) {
          this.stateIndicator.textContent = 'FOILING';
          this.stateIndicator.className = 'foiling';
        } else {
          this.stateIndicator.textContent = 'DISPLACEMENT';
          this.stateIndicator.className = 'displacement';
        }
      }
    }
    
    // =====================================================================
    // GAME MAIN
    // =====================================================================
    
    class Game {
      constructor() {
        this.input = new InputManager();
        this.physics = new PhysicsEngine();
        this.renderer = new GameRenderer();
        this.camera = new CameraController(this.renderer.camera, this.renderer.efoil.group);
        this.hud = new HUDController();
        
        // Start position
        state.position.y = 0.3;
      }
      
      start() {
        this.loop();
      }
      
      loop = () => {
        requestAnimationFrame(this.loop);
        
        this.input.update();
        this.physics.update();
        this.renderer.update();
        this.camera.update();
        this.hud.update();
        this.renderer.render();
      }
    }
    
    // =====================================================================
    // BOOT
    // =====================================================================
    
    const game = new Game();
    game.start();
    
  </script>
</body>
</html>
