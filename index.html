<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E-Foil Simulator</title>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #000;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      color: white;
      z-index: 10;
    }
    
    .hud-panel {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      padding: 12px 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    #speed-display {
      position: absolute;
      top: 20px;
      left: 20px;
    }
    
    #speed-value {
      font-size: 48px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      line-height: 1;
    }
    
    #speed-unit {
      font-size: 18px;
      opacity: 0.7;
      margin-left: 4px;
    }
    
    #battery-display {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #battery-icon {
      font-size: 24px;
    }
    
    #battery-percent {
      font-size: 24px;
      font-weight: bold;
      font-family: 'Courier New', monospace;
    }
    
    #battery-display.low {
      color: #ff4444;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    #height-gauge {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 80px;
    }
    
    #height-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .gauge-container {
      height: 120px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .gauge-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, #00ff88, #00ccff);
      transition: height 0.1s;
    }
    
    .gauge-sweet-spot {
      position: absolute;
      left: 0;
      right: 0;
      height: 30%;
      top: 35%;
      background: rgba(0, 255, 136, 0.2);
      border-top: 1px dashed rgba(0, 255, 136, 0.5);
      border-bottom: 1px dashed rgba(0, 255, 136, 0.5);
    }
    
    .gauge-value {
      position: absolute;
      bottom: -25px;
      left: 0;
      right: 0;
      text-align: center;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
    }
    
    #throttle-gauge {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 80px;
    }
    
    #throttle-label {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 8px;
      text-align: center;
    }
    
    #throttle-fill {
      background: linear-gradient(to top, #ff8800, #ffcc00);
    }
    
    #assist-badge {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      background: rgba(0, 200, 100, 0.6);
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      border: 1px solid rgba(0, 255, 136, 0.3);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #assist-badge.visible {
      opacity: 1;
    }
    
    #state-indicator {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      font-size: 14px;
      font-weight: bold;
      border-radius: 4px;
      transition: all 0.3s;
    }
    
    #state-indicator.displacement {
      background: rgba(100, 100, 255, 0.5);
      border: 1px solid rgba(150, 150, 255, 0.5);
    }
    
    #state-indicator.foiling {
      background: rgba(0, 255, 136, 0.5);
      border: 1px solid rgba(0, 255, 136, 0.5);
    }
    
    #state-indicator.breach {
      background: rgba(255, 100, 0, 0.5);
      border: 1px solid rgba(255, 150, 0, 0.5);
    }
    
    #controls-hint {
      position: absolute;
      bottom: 160px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 16px 24px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      opacity: 0;
      transition: opacity 0.5s;
      text-align: center;
      max-width: 400px;
    }
    
    #controls-hint.visible {
      opacity: 1;
    }
    
    #controls-hint h3 {
      margin-bottom: 12px;
      font-size: 16px;
      color: #00ff88;
    }
    
    .mobile-only { display: none; }
    @media (pointer: coarse) {
      .desktop-only { display: none; }
      .mobile-only { display: block; }
    }
    
    #controls-hint p {
      font-size: 13px;
      line-height: 1.6;
      opacity: 0.9;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="hud">
    <div id="speed-display" class="hud-panel">
      <span id="speed-value">0</span>
      <span id="speed-unit">km/h</span>
    </div>
    
    <div id="battery-display" class="hud-panel">
      <span id="battery-icon">âš¡</span>
      <span id="battery-percent">100%</span>
    </div>
    
    <div id="assist-badge" class="visible">STABILITY ASSIST</div>
    
    <div id="state-indicator" class="displacement">DISPLACEMENT</div>
    
    <div id="height-gauge">
      <div id="height-label">HEIGHT</div>
      <div class="gauge-container">
        <div class="gauge-sweet-spot"></div>
        <div id="height-fill" class="gauge-fill"></div>
      </div>
      <div class="gauge-value" id="height-value">0.0m</div>
    </div>
    
    <div id="throttle-gauge">
      <div id="throttle-label">THROTTLE</div>
      <div class="gauge-container">
        <div id="throttle-fill" class="gauge-fill"></div>
      </div>
      <div class="gauge-value" id="throttle-value">0%</div>
    </div>
    
    <div id="controls-hint" class="visible">
      <h3>ðŸŽ® CONTROLS</h3>
      <p class="desktop-only"><strong>W/S</strong> - Throttle Up/Down</p>
      <p class="desktop-only"><strong>A/D</strong> - Turn Left/Right</p>
      <p class="desktop-only"><strong>SHIFT</strong> - Lean Back (Rise)</p>
      <p class="desktop-only"><strong>SPACE</strong> - Lean Forward (Descend)</p>
      <p class="desktop-only"><strong>T</strong> - Toggle Stability Assist</p>
      <p class="mobile-only"><strong>Right side</strong> - Drag up/down for throttle</p>
      <p class="mobile-only"><strong>Left side</strong> - Drag to steer & pitch</p>
    </div>
  </div>

  <script type="module">
    // =====================================================================
    // E-FOIL SIMULATOR - MVP v0.1
    // =====================================================================
    
    import * as THREE from 'three';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    
    // =====================================================================
    // CONSTANTS
    // =====================================================================
    
    const PHYSICS = {
      MASS: 100,
      MAX_THRUST: 200,
      WING_AREA: 0.12,
      MAST_LENGTH: 0.75,
      WATER_DENSITY: 1025,
      GRAVITY: 9.81,
      
      // Lift coefficient curve [aoa, Cl]
      CL_CURVE: [[0, 0], [4, 0.5], [8, 1.0], [10, 1.2], [12, 1.3], [14, 0.4], [16, 0.2]],
      
      CD_FOIL: 0.03,
      CD_HULL: 0.15,
      
      STAB_GAIN: 50,
      STAB_DAMP: 30,
      
      BASE_DRAIN: 0.0002,
      POWER_DRAIN: 0.001,
      
      THROTTLE_RAMP_UP: 0.8,
      THROTTLE_RAMP_DOWN: 0.5,
      PITCH_SENSITIVITY: 2.0,
      TURN_RATE: 1.5,
      
      ASSIST_DAMPING: 0.6,
      
      // Sweet spot for optimal height
      SWEET_SPOT_MIN: 0.3,
      SWEET_SPOT_MAX: 0.6,
    };
    
    // =====================================================================
    // STATE
    // =====================================================================
    
    const state = {
      position: new THREE.Vector3(0, 0, 0),
      velocity: new THREE.Vector3(0, 0, 0),
      rotation: { pitch: 0, yaw: 0, roll: 0 },
      angularVelocity: { pitch: 0, yaw: 0, roll: 0 },
      
      throttle: 0.0,
      throttleInput: 0.0,
      pitchInput: 0.0,
      turnInput: 0.0,
      
      speed: 0,
      heightAboveWater: 0,
      angleOfAttack: 0,
      battery: 1.0,
      
      isFoiling: false,
      isCrashed: false,
      crashTime: 0,
      
      stabilityAssist: true,
      
      time: 0,
    };
    
    // =====================================================================
    // INPUT MANAGER
    // =====================================================================
    
    class InputManager {
      constructor() {
        this.keys = {};
        
        window.addEventListener('keydown', (e) => {
          this.keys[e.code] = true;
          
          // Toggle stability assist
          if (e.code === 'KeyT') {
            state.stabilityAssist = !state.stabilityAssist;
            this.updateAssistBadge();
          }
        });
        
        window.addEventListener('keyup', (e) => {
          this.keys[e.code] = false;
        });
        
        this.initTouch();
      }
      
      update() {
        // Throttle input
        if (this.keys['KeyW'] || this.keys['ArrowUp']) {
          state.throttleInput = 1.0;
        } else if (this.keys['KeyS'] || this.keys['ArrowDown']) {
          state.throttleInput = -1.0;
        } else {
          state.throttleInput = 0.0;
        }
        
        // Turn input
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
          state.turnInput = 1.0;
        } else if (this.keys['KeyD'] || this.keys['ArrowRight']) {
          state.turnInput = -1.0;
        } else {
          state.turnInput = 0.0;
        }
        
        // Pitch input
        if (this.keys['ShiftLeft'] || this.keys['ShiftRight']) {
          state.pitchInput = 1.0; // Lean back = nose up
        } else if (this.keys['Space']) {
          state.pitchInput = -1.0; // Lean forward = nose down
        } else {
          state.pitchInput = 0.0;
        }
        
        // Touch overrides keyboard if active
        this.updateTouch();
      }
      
      initTouch() {
        this.touchThrottle = null;
        this.touchSteer = null;
        
        const canvas = document.getElementById('canvas-container');
        
        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          for (const t of e.changedTouches) {
            if (t.clientX > window.innerWidth / 2) {
              this.touchThrottle = { id: t.identifier, startY: t.clientY, currentY: t.clientY };
            } else {
              this.touchSteer = { id: t.identifier, startX: t.clientX, startY: t.clientY, currentX: t.clientX, currentY: t.clientY };
            }
          }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          for (const t of e.changedTouches) {
            if (this.touchThrottle && t.identifier === this.touchThrottle.id) {
              this.touchThrottle.currentY = t.clientY;
            }
            if (this.touchSteer && t.identifier === this.touchSteer.id) {
              this.touchSteer.currentX = t.clientX;
              this.touchSteer.currentY = t.clientY;
            }
          }
        }, { passive: false });
        
        const endTouch = (e) => {
          for (const t of e.changedTouches) {
            if (this.touchThrottle && t.identifier === this.touchThrottle.id) this.touchThrottle = null;
            if (this.touchSteer && t.identifier === this.touchSteer.id) this.touchSteer = null;
          }
        };
        canvas.addEventListener('touchend', endTouch);
        canvas.addEventListener('touchcancel', endTouch);
      }
      
      updateTouch() {
        // Right side: drag up = throttle, drag down = brake
        if (this.touchThrottle) {
          const dy = (this.touchThrottle.startY - this.touchThrottle.currentY) / 100;
          state.throttleInput = Math.max(-1, Math.min(1, dy));
        }
        // Left side: horizontal = turn, vertical = pitch
        if (this.touchSteer) {
          const dx = (this.touchSteer.currentX - this.touchSteer.startX) / 60;
          const dy = (this.touchSteer.startY - this.touchSteer.currentY) / 60;
          state.turnInput = -Math.max(-1, Math.min(1, dx));
          state.pitchInput = Math.max(-1, Math.min(1, dy));
        }
      }
      
      updateAssistBadge() {
        const badge = document.getElementById('assist-badge');
        badge.classList.toggle('visible', state.stabilityAssist);
      }
    }
    
    // =====================================================================
    // PHYSICS ENGINE
    // =====================================================================
    
    class PhysicsEngine {
      constructor() {
        this.dt = 1/60; // Fixed timestep
      }
      
      // Get Cl from angle of attack using piecewise linear interpolation
      getCl(aoa) {
        const curve = PHYSICS.CL_CURVE;
        
        if (aoa <= curve[0][0]) return curve[0][1];
        if (aoa >= curve[curve.length - 1][0]) return curve[curve.length - 1][1];
        
        for (let i = 0; i < curve.length - 1; i++) {
          const [aoa1, cl1] = curve[i];
          const [aoa2, cl2] = curve[i + 1];
          
          if (aoa >= aoa1 && aoa <= aoa2) {
            const t = (aoa - aoa1) / (aoa2 - aoa1);
            return cl1 + t * (cl2 - cl1);
          }
        }
        
        return 0;
      }
      
      update() {
        if (state.isCrashed) {
          // Simple recovery countdown
          state.crashTime += this.dt;
          if (state.crashTime > 2.0) {
            this.resetToFloating();
          }
          return;
        }
        
        // Update throttle with ramping
        const rampRate = state.throttleInput > 0 ? PHYSICS.THROTTLE_RAMP_UP : PHYSICS.THROTTLE_RAMP_DOWN;
        const targetThrottle = Math.max(0, state.throttle + state.throttleInput * rampRate * this.dt);
        state.throttle = THREE.MathUtils.clamp(targetThrottle, 0, 1);
        
        // Calculate forces
        const forward = new THREE.Vector3(
          Math.sin(state.rotation.yaw),
          0,
          Math.cos(state.rotation.yaw)
        );
        
        // Thrust
        const batteryEff = 0.7 + 0.3 * state.battery;
        const thrust = state.throttle * PHYSICS.MAX_THRUST * batteryEff;
        const thrustForce = forward.clone().multiplyScalar(thrust);
        
        // Speed and angle of attack
        state.speed = state.velocity.length();
        const velocityAngle = state.speed > 0.1 ? 
          Math.atan2(state.velocity.y, Math.sqrt(state.velocity.x**2 + state.velocity.z**2)) * 180/Math.PI : 0;
        state.angleOfAttack = state.rotation.pitch - velocityAngle;
        
        // Height above water (including wave height from water shader)
        const waveHeight = Math.sin(state.position.x * 0.3 + state.time * 0.8) * 0.1 +
                          Math.sin(state.position.z * 0.2 + state.time * 0.6) * 0.08;
        state.heightAboveWater = state.position.y - waveHeight;
        
        // Lift (only when foil is submerged)
        let liftForce = new THREE.Vector3();
        const foilDepth = -state.heightAboveWater + 0.3; // Board bottom offset
        
        if (foilDepth > 0 && foilDepth < PHYSICS.MAST_LENGTH && state.speed > 0.1) {
          const cl = this.getCl(state.angleOfAttack);
          const liftMag = 0.5 * PHYSICS.WATER_DENSITY * state.speed**2 * PHYSICS.WING_AREA * cl;
          
          // Lift is perpendicular to velocity, biased upward
          const liftDir = new THREE.Vector3(0, 1, 0);
          liftForce = liftDir.multiplyScalar(liftMag);
        }
        
        // Drag (two regimes)
        let dragForce = new THREE.Vector3();
        const inWater = state.heightAboveWater < 0.1;
        const dragCoef = inWater ? PHYSICS.CD_HULL : PHYSICS.CD_FOIL;
        const dragArea = inWater ? 0.8 : 0.02;
        
        if (state.speed > 0.1) {
          const dragMag = 0.5 * PHYSICS.WATER_DENSITY * state.speed**2 * dragArea * dragCoef;
          dragForce = state.velocity.clone().normalize().multiplyScalar(-dragMag);
        }
        
        // Gravity
        const gravityForce = new THREE.Vector3(0, -PHYSICS.MASS * PHYSICS.GRAVITY, 0);
        
        // Buoyancy when in water
        let buoyancyForce = new THREE.Vector3();
        if (state.heightAboveWater < 0) {
          const submergedVolume = Math.abs(state.heightAboveWater) * 0.5; // Simplified
          const buoyancy = PHYSICS.WATER_DENSITY * PHYSICS.GRAVITY * submergedVolume;
          buoyancyForce = new THREE.Vector3(0, buoyancy, 0);
        }
        
        // Net force
        const netForce = new THREE.Vector3()
          .add(thrustForce)
          .add(liftForce)
          .add(dragForce)
          .add(gravityForce)
          .add(buoyancyForce);
        
        // Integration
        const acceleration = netForce.divideScalar(PHYSICS.MASS);
        state.velocity.add(acceleration.multiplyScalar(this.dt));
        state.position.add(state.velocity.clone().multiplyScalar(this.dt));
        
        // Pitch control
        const pitchTorque = state.pitchInput * PHYSICS.PITCH_SENSITIVITY;
        
        // Stabilizer (automatic pitch correction)
        const stabTorque = -PHYSICS.STAB_GAIN * state.rotation.pitch - 
                          PHYSICS.STAB_DAMP * state.angularVelocity.pitch;
        
        let totalPitchTorque = pitchTorque + stabTorque;
        
        // Apply stability assist damping
        if (state.stabilityAssist) {
          state.angularVelocity.pitch *= PHYSICS.ASSIST_DAMPING;
        }
        
        state.angularVelocity.pitch += totalPitchTorque * this.dt;
        state.rotation.pitch += state.angularVelocity.pitch * this.dt;
        state.rotation.pitch = THREE.MathUtils.clamp(state.rotation.pitch, -45, 45);
        
        // Yaw control (turning)
        const turnRate = state.turnInput * PHYSICS.TURN_RATE;
        state.rotation.yaw += turnRate * this.dt;
        
        // Roll from turning
        state.rotation.roll = -state.turnInput * 15; // degrees
        
        // Update foiling state
        state.isFoiling = state.heightAboveWater > 0.1 && state.heightAboveWater < PHYSICS.MAST_LENGTH;
        
        // Battery drain
        const drain = PHYSICS.BASE_DRAIN + PHYSICS.POWER_DRAIN * state.throttle**2;
        state.battery = Math.max(0, state.battery - drain * this.dt);
        
        // Crash detection
        this.checkCrash();
        
        // Time
        state.time += this.dt;
      }
      
      checkCrash() {
        const stall = state.angleOfAttack > 12 || state.angleOfAttack < -5;
        const breach = state.heightAboveWater > PHYSICS.MAST_LENGTH;
        const noseDive = state.rotation.pitch < -30 && state.isFoiling;
        
        if ((stall || breach || noseDive) && state.isFoiling && state.speed > 5) {
          state.isCrashed = true;
          state.crashTime = 0;
          
          // Show crash splash effect
          this.createSplash();
        }
      }
      
      createSplash() {
        // Visual feedback (could add particles here)
        console.log('ðŸ’¦ SPLASH!');
      }
      
      resetToFloating() {
        state.isCrashed = false;
        state.position.y = 0.3;
        state.velocity.set(0, 0, 0);
        state.rotation.pitch = 0;
        state.rotation.roll = 0;
        state.angularVelocity.pitch = 0;
        state.throttle = 0;
      }
    }
    
    // =====================================================================
    // E-FOIL MODEL BUILDER
    // =====================================================================
    
    class EFoilModel {
      constructor() {
        this.group = new THREE.Group();
        this.buildModel();
      }
      
      buildModel() {
        // Board
        const boardGeometry = new THREE.BoxGeometry(1.4, 0.08, 0.6);
        const boardMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xffffff,
          roughness: 0.3,
          metalness: 0.1,
        });
        const board = new THREE.Mesh(boardGeometry, boardMaterial);
        board.position.y = 0.3;
        this.group.add(board);
        
        // Accent stripe on board
        const stripeGeometry = new THREE.BoxGeometry(1.3, 0.09, 0.15);
        const stripeMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x00ff88,
          roughness: 0.2,
          metalness: 0.3,
        });
        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
        stripe.position.y = 0.3;
        this.group.add(stripe);
        
        // Mast
        const mastGeometry = new THREE.BoxGeometry(0.02, 0.75, 0.12);
        const mastMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x333333,
          roughness: 0.5,
          metalness: 0.8,
        });
        const mast = new THREE.Mesh(mastGeometry, mastMaterial);
        mast.position.y = -0.075;
        mast.position.z = -0.1;
        this.group.add(mast);
        
        // Front wing (main foil)
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(0.8, 0);
        wingShape.lineTo(0.7, -0.15);
        wingShape.lineTo(0.1, -0.12);
        wingShape.lineTo(0, 0);
        
        const extrudeSettings = {
          depth: 0.03,
          bevelEnabled: true,
          bevelThickness: 0.005,
          bevelSize: 0.005,
          bevelSegments: 2
        };
        
        const wingGeometry = new THREE.ExtrudeGeometry(wingShape, extrudeSettings);
        const wing = new THREE.Mesh(wingGeometry, mastMaterial);
        wing.position.y = -0.45;
        wing.position.z = 0;
        wing.position.x = -0.4;
        wing.rotation.y = Math.PI / 2;
        this.group.add(wing);
        
        // Mirror wing
        const wingLeft = wing.clone();
        wingLeft.position.x = 0.4;
        wingLeft.rotation.y = -Math.PI / 2;
        wingLeft.scale.x = -1;
        this.group.add(wingLeft);
        
        // Rear stabilizer
        const stabShape = new THREE.Shape();
        stabShape.moveTo(0, 0);
        stabShape.lineTo(0.4, 0);
        stabShape.lineTo(0.35, -0.08);
        stabShape.lineTo(0.05, -0.06);
        stabShape.lineTo(0, 0);
        
        const stabGeometry = new THREE.ExtrudeGeometry(stabShape, extrudeSettings);
        const stab = new THREE.Mesh(stabGeometry, mastMaterial);
        stab.position.y = -0.42;
        stab.position.z = -0.6;
        stab.position.x = -0.2;
        stab.rotation.y = Math.PI / 2;
        this.group.add(stab);
        
        // Mirror stab
        const stabLeft = stab.clone();
        stabLeft.position.x = 0.2;
        stabLeft.rotation.y = -Math.PI / 2;
        stabLeft.scale.x = -1;
        this.group.add(stabLeft);
        
        // Rider
        const riderGeometry = new THREE.CapsuleGeometry(0.15, 0.6, 8, 16);
        const riderMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x222222,
          roughness: 0.8,
        });
        const rider = new THREE.Mesh(riderGeometry, riderMaterial);
        rider.position.y = 0.9;
        rider.position.z = 0.1;
        this.group.add(rider);
        
        // Head
        const headGeometry = new THREE.SphereGeometry(0.12, 16, 16);
        const headMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xffdbac,
          roughness: 0.9,
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.4;
        head.position.z = 0.1;
        this.group.add(head);
      }
      
      update() {
        // Update model position and rotation
        this.group.position.copy(state.position);
        this.group.rotation.y = state.rotation.yaw;
        this.group.rotation.x = state.rotation.pitch * Math.PI / 180;
        this.group.rotation.z = state.rotation.roll * Math.PI / 180;
      }
    }
    
    // =====================================================================
    // GAME RENDERER
    // =====================================================================
    
    class GameRenderer {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        
        this.setupSky();
        this.setupLights();
        this.setupWater();
        this.setupEFoil();
        
        window.addEventListener('resize', () => this.onResize());
      }
      
      setupLights() {
        // Sunlight
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(100, 100, 50);
        this.scene.add(sun);
        
        // Ambient
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambient);
        
        // Hemisphere light for better sky-ground gradient
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
        this.scene.add(hemiLight);
      }
      
      setupWater() {
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
        
        this.water = new Water(waterGeometry, {
          textureWidth: 512,
          textureHeight: 512,
          waterNormals: new THREE.TextureLoader().load(
            'https://threejs.org/examples/textures/waternormals.jpg',
            (texture) => {
              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            }
          ),
          sunDirection: this.sunPosition ? this.sunPosition.clone().normalize() : new THREE.Vector3(0.7, 0.5, 0.3).normalize(),
          sunColor: 0xffffff,
          waterColor: 0x001e0f,
          distortionScale: 3.7,
          fog: true,
          alpha: 1.0,
        });
        
        this.water.rotation.x = -Math.PI / 2;
        this.scene.add(this.water);
      }
      
      setupSky() {
        this.sky = new Sky();
        this.sky.scale.setScalar(10000);
        this.scene.add(this.sky);
        
        const skyUniforms = this.sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 2;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        
        // Golden hour sun position
        const phi = THREE.MathUtils.degToRad(75); // Above horizon enough to light the scene
        const theta = THREE.MathUtils.degToRad(30);
        this.sunPosition = new THREE.Vector3();
        this.sunPosition.setFromSphericalCoords(1, phi, theta);
        skyUniforms['sunPosition'].value.copy(this.sunPosition);
        
        // Fog for horizon blend
        this.scene.fog = new THREE.Fog(0x87ceeb, 100, 2000);
      }
      
      setupEFoil() {
        this.efoil = new EFoilModel();
        this.scene.add(this.efoil.group);
      }
      
      update() {
        this.efoil.update();
        
        // Animate water
        if (this.water.material.uniforms['time']) {
          this.water.material.uniforms['time'].value += 1.0 / 60.0;
        }
      }
      
      render() {
        this.renderer.render(this.scene, this.camera);
      }
      
      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }
    
    // =====================================================================
    // CAMERA CONTROLLER
    // =====================================================================
    
    class CameraController {
      constructor(camera, target) {
        this.camera = camera;
        this.target = target;
        this.offset = new THREE.Vector3(0, 1.5, -3);
        this.lookAtOffset = new THREE.Vector3(0, 0.5, 1);
        this.currentPosition = new THREE.Vector3();
        this.currentLookAt = new THREE.Vector3();
      }
      
      update() {
        // Calculate desired camera position in world space
        const rotationMatrix = new THREE.Matrix4();
        rotationMatrix.makeRotationY(state.rotation.yaw);
        
        const desiredOffset = this.offset.clone().applyMatrix4(rotationMatrix);
        const desiredPosition = state.position.clone().add(desiredOffset);
        
        // Smooth follow with lerp
        this.currentPosition.lerp(desiredPosition, 0.05);
        this.camera.position.copy(this.currentPosition);
        
        // Look at point slightly ahead of board
        const desiredLookAtOffset = this.lookAtOffset.clone().applyMatrix4(rotationMatrix);
        const desiredLookAt = state.position.clone().add(desiredLookAtOffset);
        
        this.currentLookAt.lerp(desiredLookAt, 0.1);
        this.camera.lookAt(this.currentLookAt);
        
        // Add slight roll with the board
        this.camera.rotation.z = state.rotation.roll * Math.PI / 180 * 0.1;
      }
    }
    
    // =====================================================================
    // HUD CONTROLLER
    // =====================================================================
    
    class HUDController {
      constructor() {
        this.speedValue = document.getElementById('speed-value');
        this.batteryPercent = document.getElementById('battery-percent');
        this.batteryDisplay = document.getElementById('battery-display');
        this.heightFill = document.getElementById('height-fill');
        this.heightValue = document.getElementById('height-value');
        this.throttleFill = document.getElementById('throttle-fill');
        this.throttleValue = document.getElementById('throttle-value');
        this.stateIndicator = document.getElementById('state-indicator');
        this.controlsHint = document.getElementById('controls-hint');
        
        // Hide controls hint after 10 seconds
        setTimeout(() => {
          this.controlsHint.classList.remove('visible');
        }, 10000);
      }
      
      update() {
        // Speed (m/s to km/h)
        const speedKmh = state.speed * 3.6;
        this.speedValue.textContent = Math.round(speedKmh);
        
        // Battery
        const batteryPercent = Math.round(state.battery * 100);
        this.batteryPercent.textContent = `${batteryPercent}%`;
        this.batteryDisplay.classList.toggle('low', state.battery < 0.2);
        
        // Height gauge (0-2m range)
        const heightPercent = Math.min(100, Math.max(0, (state.heightAboveWater / 2) * 100));
        this.heightFill.style.height = `${heightPercent}%`;
        this.heightValue.textContent = `${state.heightAboveWater.toFixed(1)}m`;
        
        // Throttle gauge
        const throttlePercent = state.throttle * 100;
        this.throttleFill.style.height = `${throttlePercent}%`;
        this.throttleValue.textContent = `${Math.round(throttlePercent)}%`;
        
        // State indicator
        if (state.isCrashed) {
          this.stateIndicator.textContent = 'CRASHED';
          this.stateIndicator.className = 'breach';
        } else if (state.heightAboveWater >= PHYSICS.MAST_LENGTH) {
          this.stateIndicator.textContent = 'BREACH!';
          this.stateIndicator.className = 'breach';
        } else if (state.isFoiling) {
          this.stateIndicator.textContent = 'FOILING';
          this.stateIndicator.className = 'foiling';
        } else {
          this.stateIndicator.textContent = 'DISPLACEMENT';
          this.stateIndicator.className = 'displacement';
        }
      }
    }
    
    // =====================================================================
    // GAME MAIN
    // =====================================================================
    
    class Game {
      constructor() {
        this.input = new InputManager();
        this.physics = new PhysicsEngine();
        this.renderer = new GameRenderer();
        this.camera = new CameraController(this.renderer.camera, this.renderer.efoil.group);
        this.hud = new HUDController();
        
        // Start position
        state.position.y = 0.3;
      }
      
      start() {
        this.loop();
      }
      
      loop = () => {
        requestAnimationFrame(this.loop);
        
        this.input.update();
        this.physics.update();
        this.renderer.update();
        this.camera.update();
        this.hud.update();
        this.renderer.render();
      }
    }
    
    // =====================================================================
    // BOOT
    // =====================================================================
    
    const game = new Game();
    game.start();
    
  </script>
</body>
</html>
